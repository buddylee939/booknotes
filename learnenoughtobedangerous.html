<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Book Notes | Learn enough js to be dangerous</title>
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">

  </head>

  <body>
    <div id="myNav">
    
    </div>


<div class="container">
  <div class="row">
    <div class="col">
      <h1>Learn enough javascript to be dangerous - Michael Hartl</h1>
      <h2>Table of contents</h2>
      <ul>
        <li>hello world and how to deploy to github pages</li>
        <li>REPL - read, evaluate, print, loop</li>
        <li>strings</li>
        <li>concatenation and interpolation</li>
        <li>printing</li>
        <li>properties, booleans and control flow</li>
        <li>methods</li>
        <li>string iteration</li>
        <li>arrays</li>
        <li>splitting and array access</li>
        <li>native objects</li>
        <li>math and number</li>
        <li>dates</li>
        <li>REGEX</li>
        <li>plain objects</li>
        <li>functions</li>
        <li>method chaining</li>
        <li>iteration for each</li>
        <li>functional programming</li>
        <li>map</li>
        <li>filter</li>
        <li>reduce</li>
        <li>objects and prototypes</li>
        <li>testing and TDD</li>
        <li>events and the DOM</li>
        <li>event listeners</li>
        <li>dynamic HTML</li>
        <li>form handling</li>
        <li>node.js</li>
        <li>reading from files</li>
        <li>reading from urls</li>
        <li>DOM manipulation</li>
        <li>image gallery</li>
      </ul>      
    </div>
  </div>
</div>
<hr>
<div class="container">
  <div class="row">
    <div class="col">
      <h2>Chapter 1 - hello world</h2>
      <p>the alert('hello world'): alert is a js function</p>
      <h3>How to deploy to git hub pages</h3>
      <ol>
        <li>login and create a repo in github</li>
        <li>git init the folder with a index.html at least</li>
        <li>git push the folder up</li>
        <li>in github, go to the repo and click on settings</li>
        <li>go down to 'github pages' and choose 'source' as 'master branch'</li>
        <li>now go to: https://&lt;username&gt;/github.io/&lt;reponame&gt; </li>
        <li>and voila</li>
      </ol>
      <hr>
      <h2>Chapter 1.2 JS in a REPL</h2>
      <p>REPL is a program that reads input, evaluates it, prints out the result, and then loops back to the read step</p>
      <p>developer tools in chrome are default, in safari, they have to be installed</p>
      <p>console is a js object, .log is a function of console; <i>in the context of objects, a function like log called suing the dot notation is often called a <b>method</b></i></p>
      <p>to run js in the command line, use node: to check type 'which node'</p>
      <p>you should see the path, if not installed, brew install node; or go to the node website</p>
      <p>instead of using console, to run the hello world in node</p>
      <p>in terminal type: node, then: console.log('hello world')</p>
      <p>to exit type '.exit'</p>
      <hr>
      <h2>Chatper 1.3 JS in a file</h2>
      <p>adding a js file</p>
      <hr>
      <h2>Chapter 1.4 JS in a shell script</h2>
      <p>create a file 'hello' with no extension</p>
      <p>in it write "#!/usr/local/bin/node console.log('hello shell');"</p>
      <p>in the command line type 'chmod +x hello'</p>
      <p>type './hello' and it should execute the shell script</p>
    </div>
  </div>
</div>
<div class="container">
  <div class="row">
    <div class="col">
      <h2>Chapter 2 - strings</h2>
      <p>basic string example</p>
      <hr>
      <h2>Chapter 2.2 - concatenation and interpolation</h2>
      <p>'concatenation' is joing string together, and 'interpolation' is putting variable content into strings</p>
      <p>we can use 'let' to create variables, it is characteristic in modern JS, ECMAscript 6</p>
      <p>we can also use 'const' and 'var' is still popular</p>
      <p>using 'backticks': another way to build strings is interpolation, using ES6 backtick syntax, known and 'template literals'</p>
      <pre>
        // with curly brackets
        `${firstName} is my first name`
        `${firstName} ${lastName}`
      </pre>
      <p>once you declare a variable, with let or var, you can't declare it again</p>
      <pre>
        // gives a syntax error that 'firstName' has already been declared
        let firstName = 'Pep';
        var firstName = 'Steve';
      </pre>
      <hr>
      <h2>Chapter 2.4 - properties, booleans, and control flow</h2>
      <p>almost everything in js, including strings, is an object</p>
      <p>example: 'badger'.length is the length property called on the string object, it is the 'only' property of a string object</p>
      <p>always use the '===' to test values, because, "1" == 1, is true</p>
      <p><i>George Boole, thats where booleans come from</i></p>
      <p><b>control flow</b>: booleans are useful in the flow of a program</p>
      <pre>
        let password = 'foo';
        if (password.length < 6){
          'password is too short';
        } else {
          'password is long enough';
        }
      </pre>
      <p><b>side note: try and keep your code width to 80 characters, if it passes, then maybe break up the code to several lines</b></p>
      <p>here is 80 characters</p>
      <p>11111111111111111111111111111111111111111111111111111111111111111111111111111111</p>
      <p>using &amp;&amp;, || and !</p>
      <pre>
        let x = 'foo';
        let y = '';
        if (x.length === 0 &amp;&amp; y.length === 0){
          'both strings are empty';
        } else {
          'at least one of the strings is nonempty';
        }

        if (x.length !== 0) // if not equal
      </pre>
      <p>there is even 'bang bang' which is !!</p>
      <pre>
        !!true
        > !'foo'
        false
        > !!'foo'
        true
        >         
      </pre>
      <hr>
      <h2>Chapter 2.5 - methods</h2>
      <p> In the language of object-oriented programming, a particular string, or string instance, is said to “respond to” a particular method, indicated using the dot notation first seen in </p>
      <p>strings respond to instance method toLowerCase()</p>
      <pre>
        "HONEY BADGER".toLowerCase()
      </pre>
      <p>Starting with ECMAScript 2015, string literals can also be so-called Template literals:</p>
      <p>long string literals: when your paragraph goes on and on, wrapping based on the text editor, it is better to do this:</p>
      <pre>
        let longString = "This is a very long string which needs " +
        "to wrap across multiple lines because " +
        "otherwise my code is unreadable.";
      </pre>
      <p>or using the backslash character</p>
      <pre>
        let longString = "This is a very long string which needs \
        to wrap across multiple lines because \
        otherwise my code is unreadable.";        
      </pre>
      <p>List of methods unrelated to HTML</p>
      <ol>
        <li>String.charAt()</li>
        <li>String.charCodeAt()</li>
        <li>String.codePointAt()</li>
        <li>String.concat()</li>
        <li>String.includes()</li>
      </ol>
      <pre>
> let soliloquy = "To be, or not to be, that is the question:";
> soliloquy.includes("To be");        // Does it include the substring "To be"?
true
> soliloquy.includes("question");     // What about "question"?
true
> soliloquy.includes("nonexistent");  // This string doesn't appear.
false
> soliloquy.includes("TO BE");        // String inclusion is case-sensitive.
false
> soliloquy.includes("To be", 1);     // Can you guess what this one means?
false
> soliloquy.includes("o be,", 1);     // A hint for the previous one
true        
      </pre>
      <p class="bold">Check if a string includes "TO BE", starting the search at position 1: it starts to search within the string, starting at i position, and looking forward</p>
      <hr>
      <h2>Chapter 2.6 - string iteration</h2>
      <p>one sign of your growing power as a developer is learning how to avoid iteration entirely</p>
      <pre>
> for (let i = 0; i < 5; i++) {
  console.log(i);        
      </pre>
      <p class="bold">If you find the code in Listing 24 confusing or ugly, you’re in good company. I consider it a hallmark of good programming to using avoid for loops as much as possible, preferring instead forEach loops </p>
      <pre>
> for (let i = 0; i < soliloquy.length; i++) {
  console.log(soliloquy.charAt(i));        
      </pre>
      <pre>
var str = 'Lorem ipsum dolor sit amet, consectetur adipisicing' +
          'elit. Atque dolor, culpa natus, deleniti, tempora' + 
          'architecto vel ex quaerat in soluta sit velit autem.';
var N = str.length;           
for (var i = 0; i < N; i++){
  console.log(str.charAt(i));
  console.log(str[i]); // or using literal bracket notation
}                     
      </pre>      
    </div>
  </div>
</div>
<div class="container">
  <div class="row">
    <div class="col">
      <h2>Chapter 3 - Arrays</h2>
      <h3>Chapter 3.1 - splitting and array access</h3>
      <pre>
>  "ant bat cat".split(" ");     // Split a string into a three-element array.
[ 'ant', 'bat', 'cat' ]        
      </pre>  
      <p><b>split</b> returns a list of the strings seperated by ' ' space</p>    
      <pre>
> "ant,bat,cat".split(",");
[ 'ant', 'bat', 'cat' ]
> "ant, bat, cat".split(", ");
[ 'ant', 'bat', 'cat' ]
> "antheybatheycathey".split("hey");
[ 'ant', 'bat', 'cat' ]   
> "badger".split("")
[ 'b', 'a', 'd', 'g', 'e', 'r' ]     
      </pre>
      <hr>
      <h2>Chapter 3.2 - array access</h2>
      <p>Excercises</p>
      <hr>
      <h2>Chapter 3.3 - array slicing</h2>
      <pre>
> a = [42, 8, 17, 99];
[ 42, 8, 17, 99 ]        
      </pre>     
      <p>The simplest way to slice an array is to provide only one argument, which returns all the elements in the array from that index on. For example, for an array with four elements, slice(1) returns the second, third, and fourth ones (recall that the “first” or zeroth element has index 0):</p> 
      <pre>
> a.slice(1);
[ 8, 17, 99 ]
      </pre>
      <p>We can also slice from one index to another:</p>
      <pre>
> a.slice(1, 3);
[ 8, 17 ]        
      </pre>
      <p>finding the last element of an array</p>
      <pre>
> a.length;
4
> a[a.length-1];
99        
      </pre>
      <p>This leads us to a second method for picking off the last element, which is to use slice with a negative number, which counts from the end:</p>
      <pre>
> aMuchLongerArrayName.slice(-1);
[ 99 ]        
      </pre>
      <p>This returns an array with one element, so we can select the element itself using the bracket notation:</p>
      <pre>
> aMuchLongerArrayName.slice(-1)[0];
99        
      </pre>
      <h4>Exercises:</h4>
      <p>Define an array with the numbers 1 through 10. Use slicing and length to select the third element through the third-to-last. Accomplish the same task using a negative index.</p>
      <p>Show that strings also support the slice method by selecting just bat from the string "ant bat cat". (You might have to experiment a little to get the indices just right.)</p>
      <pre>
var myArr = [1,2,3,4,5,6,7,8,9,10];
console.log(myArr.slice(2, myArr.length-3));
console.log(myArr.slice(-8,-3));

var test = 'ant bat cat';
console.log(test.slice(4,7));        
      </pre>
      <hr>
      <h2>Chapter 3.4 - more array methods</h2>
      <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Check the documentation for more methods</a>
      <p>using 'includes'</p>
      <pre>
> a;
[ 42, 8, 17, 99 ]
> a.includes(42);       // Test for element inclusion.
true
> a.includes("foo");
false        
      </pre>
      <p>sorting and reversing</p>
      <pre>
> a.sort();
[ 17, 42, 8, 99 ]
> a;                    // `a` has changed as the result of `sort()`.
[ 17, 42, 8, 99 ]        
      </pre>
      <p><i>You might notice something strange here, which is that JavaScript has sorted the elements of the array not according to their numerical values, but rather “alphabetically”, so that 17 comes before 8 because 1 comes before 8 in the ordering scheme (ASCII) used by computers. (We’ll learn how to sort arrays numerically in Chapter 5.)</i></p>
      <pre>
> a.reverse();
[ 99, 8, 42, 17 ]
> a;                    // Like `sort()`, `reverse()` mutates the array.
[ 99, 8, 42, 17 ]        
      </pre>
      <p>Pushing and Popping</p>
      <pre>
> a.push(6);                   // Pushing onto an array (returns new length)
5
> a;
[ 99, 42, 8, 17, 6 ]
> a.push("foo");
6
> a;
[ 99, 42, 8, 17, 6, 'foo' ]
> a.pop();                    // `pop` returns the value itself
'foo'
> a.pop();
6
> a.pop();
17
> a;
[ 99, 42, 8 ]        
      </pre>
      <p>As noted in the comments, pop returns the value of the final element (while removing it as a side-effect), but push (somewhat counter-intuitively) returns the length of the new array. As of this writing, I don’t know why (and neither does Stack Overflow).</p>
      <p>Join method</p>
      <pre>
> a = ["ant", "bat", "cat", 42];
[ 'ant', 'bat', 'cat', 42 ]
> a.join();                       // Join on default (comma).
'ant,bat,cat,42'
> a.join(", ");                   // Join on comma-space.
'ant, bat, cat, 42'
> a.join(" -- ");                 // Join on double dashes.
'ant -- bat -- cat -- 42'        
      </pre>      
      <h4>Exercises</h4>
      <p>The split and join methods are almost inverse operations, but not quite. In particular, confirm using === that a.join(" ").split(" ") in Listing 27 is not the same as a. Why not?</p>
      <p>Using the array documentation, figure out how to push onto or pop off the front of an array. Hint: The names aren’t intuitive at all, so you might have to work a bit.</p>
      <pre>
var newArr = ["ant", "bat", "cat", 42];
var newArrJ = newArr.join(" ");
var newArrS = newArrJ.split(" ");
console.log(newArrJ === newArrS);
> a
[ 11, 12, 14, 23 ]
> a.shift(34) // to pop off from the front
11
> a
[ 12, 14, 23 ]
> a.unshift(43) // to add to the front
4
> a
[ 43, 12, 14, 23 ]        
      </pre>
      <hr>
      <h2>Chapter 3.5 - string iteration</h2>
      <pre>
> for (let i = 0; i < a.length; i++) {
    console.log(a[i]);
  }
ant
bat
cat
42        
      </pre>     
      <h4>Exercises</h4> 
      <p>Show that the identifier i is undefined both before and after a for loop executes. (You might have to exit and re-enter the Node console.)</p>
      <p>Define an accumulator variable total and combine it with a loop to add all the elements of Listing 29. You can use the code in Listing 30 to get started (just replace the comment with the proper code). How does the value of total compare to a.join("")?</p>
      <pre>
var total = '';
for (var i = 0; i < newArr.length; i++){
  total += newArr[i];
}
console.log(total);
var totalArr = newArr.join('');
console.log(totalArr);
console.log(totalArr === total);        
      </pre>
    </div>
  </div>
</div> <!-- Chapter 3 arrays -->
<div class="container">
  <div class="row">
    <div class="col">
      <h2>Chapter 4 - other native objects</h2>
      <h3>Chapter 4.1 - Math and number</h3>
      <p>Global object called 'Math'</p>
      <pre>
> Math.PI
3.141592653589793
> Math.pow(2, 3);
8
> Math.sqrt(3)
1.7320508075688772
> Math.cos(2*Math.PI)
1   
> Math.log(Math.E);
1
> Math.log(10);
2.302585092994046
> Math.log10(10);
1
> Math.log10(1000000);
6
> Math.log10(Math.E);
0.4342944819032518     
      </pre>
      <p>Mathematicians typically indicate base-ten logarithms using log10, and JavaScript follows suit with log10:</p>
      <p>using the 'toString()' method</p>
      <pre>
> let tau = 2 * Math.PI;
> tau.toString();
'6.283185307179586'        
      </pre>
      <p>The toString() method won’t work on a bare integer:</p>
      <pre>
> 100.toString();
100.toString();
^^^^

SyntaxError: Invalid or unexpected token        
      </pre>
      <p>But it will work if you use an extra dot, so that JavaScript treats the number as a float:</p>
      <pre>
> 100.0.toString()
'100'        
      </pre>
      <p>Another way to convert raw numbers to strings is to use the String object directly:</p>
      <pre>
> String(100);
'100'
> String(100.0);
'100.0'
> String(tau);
'6.283185307179586'        
      </pre>
      <p>This method of converting to strings dovetails nicely with going the opposite direction, which uses the Number object directly:</p>
      <pre>
> Number("6.283185307179586");
6.283185307179586
> String(Number("6.283185307179586"));
'6.283185307179586'
> Number('1.24e6')
1240000        
      </pre>
      <h2>Chapter 4.2 - Dates</h2>
      <p>using the 'new' function, a a so-called constructor function that is the standard JavaScript way to create a new object.</p>
      <pre>
> let s = new String("A man, a plan, a canal—Panama!");
> s
[String: 'A man, a plan, a canal—Panama!']
> s.split(", ")
[ 'A man', 'a plan', 'a canal—Panama!' ]
> let a = new Array();
> a.push(3);
1
> a.push(4);
2
> a.push("hello, world!");
3
> a
[ 3, 4, 'hello, world!' ]        
      </pre>
      <p>Unlike strings and arrays, dates have no literal constructor, so we have to use new in this case:</p>
      <pre>
> let now = new Date();
> now
2018-03-01T05:01:47.136Z
> let moonLanding = new Date("July 20, 1969 20:18");
> now - moonLanding
1534038227136        
      </pre>
      <p>he result here is the number of milliseconds since the day and time of the first Moon landing (Figure 32).22 (Your results, of course, will vary, because time marches on, and your value for new Date() will differ.)</p>
      <p>using 'const'</p>
      <pre>
  const daysOfTheWeek = ["Sunday", "Monday", "Tuesday", "Wednesday",
                         "Thursday", "Friday", "Saturday"];      
      </pre>
      <p>Here const, which (as you can probably guess) is short for “constant”, gives us a way to indicate that the value of the variable won’t change.23 Some people even go so far as to use const in preference to let whenever possible. My preference is to use let as a default, and to use const as a signal that it’s especially important for the value not to change.</p>    
      <hr>
      <h2>Chapter 4.3 - Regular Expressions (Regex)</h2>
      <p>Use regex101.com when attempting to use regular expressions</p>
      <hr>
      <h2>Chapter 4.4 - plain objects</h2>
      <p>In general, objects in JavaScript can be dizzyingly complex, but in their simplest incarnation they work much like hashes (also called associative arrays) in other languages. You can think of them is being like regular arrays but with strings rather than integers as indices. Each element is thus a pair of values: a string (the key) and an element of any type (the value). These elements are also known as key/value pairs.</p>
      <pre>
> let user = {};                    // {} is an empty Object.
{}
> user["firstName"] = "Michael";    // Key "firstName", value "Michael"
'Michael'
> user["lastName"] = "Hartl";       // Key "lastName", value "Hartl"
'Hartl'        
      </pre>
      <p>The keys in our object are nothing other than the properties we first met in Section 2.4, and as such they can also be accessed using the dot notation we saw with, e.g., string.length:</p>
      <pre>
> user.firstName;        // Element access using the dot notation
'Michael'
> user.lastName;
'Hartl'        
      </pre>
      <hr>
      <h2>Chapter 4.5 - Unique words</h2>
      <p>heres a program to find the count of unique words</p>
      <pre>
const sonnet = `Let me not to the marriage of true minds
Admit impediments. Love is not love
Which alters when it alteration finds,
Or bends with the remover to remove.
O no, it is an ever-fixed mark
That looks on tempests and is never shaken;
It is the star to every wand'ring bark,
Whose worth's unknown, although his height be taken.
Love's not time's fool, though rosy lips and cheeks
Within his bending sickle's compass come:
Love alters not with his brief hours and weeks,
But bears it out even to the edge of doom.
  If this be error and upon me proved,
  I never writ, nor no man ever loved.`;

// Unique words
let uniques = {};
// All words in the text
let reg = /[\w]+/g;
let words = sonnet.match(reg);
// console.log(words.length)
// Iterate through `words` and build up an associative array of unique words.
for (let i = 0; i < words.length; i++) {
  let word = words[i];
  if (uniques[word]) {
    uniques[word] += 1;
  } else {
    uniques[word] = 1;
  }
}

console.log(uniques)

// > let uniques = new Map();
// Map {}
// > uniques.set("loved", 0);
// Map { 'loved' => 0 }
// > let currentValue = uniques.get("loved");
// > uniques.set("loved", currentValue + 1);
// Map { 'loved' => 1 }

let uniquesMap = new Map();
// let reg = /[\w]+/g;
// let words = sonnet.match(reg);
for (let i = 0; i < words.length; i++) {
  let word = words[i];
  if (uniquesMap.get(word)){
    let currentValue = uniquesMap.get(word)
    uniquesMap.set(word, currentValue + 1)
  } else {
    uniquesMap.set(word, 1)
  }
}
console.log(uniquesMap);        
      </pre>
      <form action="">
        <textarea rows="4" cols="50" id="textarea" placeholder="Enter Text Here..."></textarea>
        <input type="submit" id="btnSubmit">
      </form>
      <p>here is the word counting with sorting</p>
      <pre>
function sortWords(object){
  var sortable = [];
  for (var newWord in object) {
      sortable.push([newWord, object[newWord]]);
  }

  sortable.sort(function(a, b) {
      return a[1] - b[1];
  });

  console.log('There are now ' + sortable.length + ' unique words in that text');
  console.log(sortable.reverse());  
}

function uniqueWord(textarea){  
  let uniquesW = {};
  let regex = /[\w'-]+/g;

  let wordsNew = textarea.match(regex);
  for (let i = 0; i < wordsNew.length; i++) {
    let word = wordsNew[i].toLowerCase();
    if (uniquesW[word]) {
      uniquesW[word] += 1;
    } else {
      uniquesW[word] = 1;
    }
  }
  // console.log(uniquesW); 
  return uniquesW;
}

$('#btnSubmit').click(function(e){
  var wordObject = {};
  e.preventDefault();
  var textarea = $('#textarea').val();
  wordObject = uniqueWord(textarea);
  // console.log(wordObject);
  sortWords(wordObject);
});
        
      </pre>
    </div>
  </div>
</div> <!-- chapter 4 -->
<div class="container">
  <div class="row">
    <div class="col">
      <h2>Chapter 5 - functions</h2>
      <h3>Function definitions</h3>
      <p>sorting numerical arrays</p>
      <pre>
> let a = [8, 17, 42, 99];
> a.sort();
[ 17, 42, 8, 99 ]        
      </pre>
      <p>that sorts alphabetically, but to do numercically</p>
      <pre>
> function numberCompare(a, b) {
    if (a > b) {
      return 1;
    } else if (a < b) {
      return -1;
    } else {
      return 0;
    }
  }
> a.sort(numberCompare);
[ 8, 17, 42, 99 ]          
      </pre>
      <p>Fat arrows: ES6 adds a second method for defining functions known as a “fat arrow”, indicated with an equals sign followed by a right angle bracket: =>. We can define an alternate string message function by combining => and let keyword:</p>
      <pre>
> let alt_string_message = (string) => {
    if (string) {
      return "The string is nonempty.";
    } else {
      return "It's an empty string!";
    }
  }
> alt_string_message("honey badger");
'The string is nonempty '        
      </pre>
      <p>in other words, these are the same</p>
      <pre>
function name(arg) {
  // code
}
let name = (arg) => {
  // code
}        
      </pre>
      <h2>Chapter 5.2 functions in a file</h2>
      <p>creating a date function</p>
      <pre>
function dayOfTheWeek(date) {
  const daysOfTheWeek = ["Sunday", "Monday", "Tuesday", "Wednesday",
                         "Thursday", "Friday", "Saturday"];
  return daysOfTheWeek[date.getDay()];
}

let now = new Date();
alert(`Hello, world! Happy ${dayOfTheWeek(now)}.`);        
      </pre>
      <h2>Chapter 5.3 - method chaining</h2>
      <p>palindrome test</p>
      <pre>
// Reverses a string.
function reverse(string) {
  return string.split("").reverse().join("");
}

// Returns true for a palindrome, false otherwise.
function palindrome(string) {
  let processedContent = string.toLowerCase();
  return processedContent === reverse(processedContent);
}
alert(palindrome("racecar"));        
      </pre>
      <p>he did one version with emojis</p>
      <pre>
// Reverses a string.
function reverse(string) {
  return Array.from(string).reverse().join("")
}

// Returns true for a palindrome, false otherwise.
function palindrome(string) {
  let processedContent = string.toLowerCase();
  return processedContent === reverse(processedContent);
}
function emailParts(email) {
  // FILL IN
}        
      </pre>
      <h2>Chapter 5.4 - iteration for each</h2>
      <p>regular for loop</p>
      <pre>
for (let i = 0; i < array.length; i++) {
  console.log(array[i]);
}        
      </pre>
      <p>with the forEach</p>
      <pre>
array.forEach(function(element) {
  console.log(element);
});
> [42, 17, 85].forEach(function(element) {
    console.log(element);
  });
42
17
85
let a = ["ant", "bat", "cat", 42];
a.forEach(function(element) {
  console.log(element);
});        
      </pre>
      <p>Array.from</p>
      <pre>
> Array.from("honey badger");
[ 'h', 'o', 'n', 'e', 'y', ' ', 'b', 'a', 'd', 'g', 'e', 'r' ]        
      </pre>
      <pre>
let soliloquy = "To be, or not to be, that is the question:";
Array.from(soliloquy).forEach(function(character) {
  console.log(character);
});        
      </pre>
    </div>
  </div>
</div> <!-- Chapter 5 -->
<div class="container">
  <div class="row">
    <div class="col">
      <h2>Chapter 6 - functional programming</h2>
      <h3>using the MAP function</h3>
      <p>this is with a forEach loop</p>
      <pre>
let states = ["Kansas", "Nebraska", "North Dakota", "South Dakota"];

// map: Imperative version
function imperativeMap(states) {
  let urlStates = [];
  states.forEach(function(state) {
    urlStates.push(state.toLowerCase().split(/\s+/).join("-"));
  });
  return urlStates;
}
console.log(imperativeMap(states));        
      </pre>
      <p>this is using MAP</p>
      <pre>
        [1, 2, 3, 4].map(function(n) { return n * n; });
        [ 1, 4, 9, 16 ]
      </pre>
      <p>Even better, for the very common case of a function of a single argument, JavaScript allows us to omit the parentheses, curly braces, and even the return keyword, leading to the following incredibly compact code:</p>
      <pre>
> [1, 2, 3, 4].map(n => n * n);
[ 1, 4, 9, 16 ]        
      </pre>
      <p>redoing the forEach with map</p>
      <pre>
// map: Functional version
function functionalMap(states) {
  return states.map(state => state.toLowerCase().split(/\s+/).join('-'));
}
console.log(functionalMap(states));      
      </pre>
      <p>Defining this function in functional.js and using it in the imperative and functional versions gives the code in Listing 56.</p>
      <pre>
let states = ["Kansas", "Nebraska", "North Dakota", "South Dakota"];

// Returns a URL-friendly version of a string.
//  Example: "North Dakota" -> "north-dakota"
function urlify(string) {
  return string.toLowerCase().split(/\s+/).join('-');
}

// map: Imperative version
function imperativeMap(states) {
  let urlStates = [];
  states.forEach(function(state) {
    urlStates.push(urlify(state));
  });
  return urlStates;
}
console.log(imperativeMap(states));

// map: Functional version
function functionalMap(states) {
  return states.map(state => urlify(state));
}
console.log(functionalMap(states));        
      </pre>
      <h2>6.2 Filter</h2>
      <p>We can combine % and filter to process an array of numbers and select just the even ones:</p>
      <pre>
> [1, 2, 3, 4, 5, 6, 7, 8].filter(n => n % 2 === 0);
[ 2, 4, 6, 8 ]        
      </pre>
      <p>We can apply filter to the code from Section 6.1 to filter out the strings in our states array that consist of more than one word, keeping the names that have only one. As before, we’ll write an imperative version first:</p>
      <pre>
let states = ["Kansas", "Nebraska", "North Dakota", "South Dakota"];
.
.
.
// filter: Imperative version
function imperativeFilter(states) {
  let singleWordStates = [];
  states.forEach(function(state) {
    if (state.split(/\s+/).length === 1) {
      singleWordStates.push(state);
    }
  });
  return singleWordStates;
}
console.log(imperativeFilter(states));        
      </pre>
      <p>the using the filter</p>
      <pre>
let states = ["Kansas", "Nebraska", "North Dakota", "South Dakota"];
.
.
.
// filter: Imperative version
function imperativeFilter(states) {
  let singleWordStates = [];
  states.forEach(function(state) {
    if (state.split(/\s+/).length === 1) {
      singleWordStates.push(state);
    }
  });
  return singleWordStates;
}
console.log(imperativeFilter(states));

// filter: Functional version
function functionalFilter(states) {
  return states.filter(state => state.split(/\s+/).length === 1);
}
console.log(functionalFilter(states));        
      </pre>
      <h2>Using Reduce</h2>
      <p>We’ll begin with an iterative solution for the sum function, which involves (as usual) a forEach loop and an auxiliary variable (total), which we use to accumulate the result. The result appears in Listing 59.</p>
      <pre>
let a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// reduce: Iterative solution
function iterativeSum(array) {
  let total = 0;
  array.forEach(function(n) {
    total += n;
  });
  return total;
}
console.log(iterativeSum(a));        
      </pre>
      <p>the reduce solution</p>
      <pre>
> let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
> array.reduce((total, n) => {
    total += n;
    return total;
  }, 0);
55        
      </pre>
      <p>You can see what I meant by “tricky”. The reduce method takes a function of two arguments, the first of which is an accumulator for the result, and the second of which is the array element itself. The return value of the (anonymous) function gets passed back to reduce as the starting value for the next element in the array. The second argument is the initial value of the accumulator (in this case, 0).</p>
      <pre>
> array.reduce((total, n) => { return total += n }, 0);
55        
      </pre>
      <p>Second, the initial value is 0 by default, so in this case it can be left off:</p>
      <pre>
> array.reduce((total, n) => { return total += n });
55        
      </pre>
      <p>the full versions</p>
      <pre>
let a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// reduce: Iterative solution
function iterativeSum(array) {
  let total = 0;
  array.forEach(function(n) {
    total += n;
  });
  return total;
}
console.log(iterativeSum(a));

// reduce: Functional solution
function functionalSum(array) {
  return array.reduce((total, n) => { return total += n });
}
console.log(functionalSum(a));        
      </pre>
      <p>reduce example 2</p>
      <pre>
function imperativeLengths(states) {
  let lengths = {};
  states.forEach(function(state) {
    lengths[state] = state.length;
  });
  return lengths;
}
console.log(imperativeLengths(states));        
      </pre>
      <p>the full code</p>
      <pre>
// reduce object: Imperative solution
function imperativeLengths(states) {
  let lengths = {};
  states.forEach(function(state) {
    lengths[state] = state.length;
  });
  return lengths;
}
console.log(imperativeLengths(states));

// reduce object: Functional solution
function functionalLengths(states) {
  return states.reduce((lengths, state) => {
                          lengths[state] = state.length;
                          return lengths;
                        }, {});
}
console.log(functionalLengths(states));        
      </pre>
    </div>
  </div>
</div> <!-- chapter 6 -->
<div class="container">
  <div class="row">
    <div class="col">
      <h2>Chapter 7 - objects and prototypes</h2>
      <h3>Chapter 7.1 - Defining Objects</h3>
      <pre>
> function Phrase(content) {
    this.content = content;
  }        
      </pre>
      <pre>
let greeting = new Phrase("Hello, world!");        
      </pre>
      <pre>
> greeting.content;
'Hello, world!'        
      </pre>
      <p>Putting the palindrome method into the appropriate place in the Phrase method gives the code shown in Listing 64. Note that we can use the reverse method even inside an object definition; we’ll implement an even nicer way of reverse-ing strings in Section 7.3.</p>
      <pre>
// Defines a Phrase object.
function Phrase(content) {
  this.content = content;

  // Returns true if the phrase is a palindrome, false otherwise.
  this.palindrome = function palindrome() {
    let processedContent = this.content.toLowerCase();
    return processedContent === reverse(processedContent);
  }
}
let phrase = new Phrase('racecar');
console.log(phrase.content.toLowerCase() + ' is ' + phrase.palindrome());        
      </pre>
      <h2>7.2 Prototypes</h2>
      <p>using prototypes</p>
      <pre>
// Reverses a string.
function reverse(string) {
  return Array.from(string).reverse().join("");
}

function Phrase(content) {
  this.content = content;

  this.processor = function(string) {
    return string.toLowerCase();
  }

  this.processedContent = function() {
    return this.processor(this.content);
  }

  // Returns true if the phrase is a palindrome, false otherwise.
  this.palindrome = function() {
    return this.processedContent() === reverse(this.processedContent());
  }
}

function TranslatedPhrase(content, translation) {
  this.content = content;
  this.translation = translation;

  // Returns translation processed for palindrome testing.
  this.processedContent = function() {
    return this.processor(this.translation);
  }
}

TranslatedPhrase.prototype = new Phrase();

let frase = new TranslatedPhrase("recognize", "reconocer");
console.log('Frase Palindrome, true or false: ' + frase.palindrome());              
console.log(frase);        
      </pre>
      <h2>7.3 Modifying native objects</h2>
      <pre>
String.prototype.reverse = function() {
    return Array.from(this).reverse().join("");
  }        
      </pre>
      <pre>
> "foobar".reverse();
'raboof'
> "Racecar".reverse();
'racecaR'
> let string = "Able was I ere I saw Elba";
> string.reverse();
'ablE was I ere I saw elbA'        
      </pre>
      <p>using it in the palindrom.js</p>
      <pre>

// Adds `reverse` to all strings.
String.prototype.reverse = function() {
  return Array.from(this).reverse().join("");
}

// Defines a Phrase object.
function Phrase(content) {
  this.content = content;

  // Returns content processed for palindrome testing.
  this.processedContent = function processedContent() {
    return this.content.toLowerCase();
  }

  // Returns true if the phrase is a palindrome, false otherwise.
  this.palindrome = function palindrome() {
    return this.processedContent() === this.processedContent().reverse();
  }
}        
      </pre>      
    </div>
  </div>
</div> <!-- chapter 7 -->
<div class="container">
  <div class="row">
    <div class="col">
      <h2>8 Testing and test-driven development</h2>
    </div>
  </div>
</div> <!-- chapter 8 -->


<footer>
  copyright &copy; 2018
</footer>
    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/navbar.js"></script>
    <script src="js/script.js"></script>
    <script src="js/learnenough.js"></script>
  </body>
</html>


